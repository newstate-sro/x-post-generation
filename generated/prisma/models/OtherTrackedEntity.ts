
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `OtherTrackedEntity` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model OtherTrackedEntity
 * 
 */
export type OtherTrackedEntityModel = runtime.Types.Result.DefaultSelection<Prisma.$OtherTrackedEntityPayload>

export type AggregateOtherTrackedEntity = {
  _count: OtherTrackedEntityCountAggregateOutputType | null
  _min: OtherTrackedEntityMinAggregateOutputType | null
  _max: OtherTrackedEntityMaxAggregateOutputType | null
}

export type OtherTrackedEntityMinAggregateOutputType = {
  id: string | null
  facebookPageUrl: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type OtherTrackedEntityMaxAggregateOutputType = {
  id: string | null
  facebookPageUrl: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type OtherTrackedEntityCountAggregateOutputType = {
  id: number
  facebookPageUrl: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type OtherTrackedEntityMinAggregateInputType = {
  id?: true
  facebookPageUrl?: true
  createdAt?: true
  updatedAt?: true
}

export type OtherTrackedEntityMaxAggregateInputType = {
  id?: true
  facebookPageUrl?: true
  createdAt?: true
  updatedAt?: true
}

export type OtherTrackedEntityCountAggregateInputType = {
  id?: true
  facebookPageUrl?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type OtherTrackedEntityAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which OtherTrackedEntity to aggregate.
   */
  where?: Prisma.OtherTrackedEntityWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of OtherTrackedEntities to fetch.
   */
  orderBy?: Prisma.OtherTrackedEntityOrderByWithRelationInput | Prisma.OtherTrackedEntityOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.OtherTrackedEntityWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` OtherTrackedEntities from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` OtherTrackedEntities.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned OtherTrackedEntities
  **/
  _count?: true | OtherTrackedEntityCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: OtherTrackedEntityMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: OtherTrackedEntityMaxAggregateInputType
}

export type GetOtherTrackedEntityAggregateType<T extends OtherTrackedEntityAggregateArgs> = {
      [P in keyof T & keyof AggregateOtherTrackedEntity]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateOtherTrackedEntity[P]>
    : Prisma.GetScalarType<T[P], AggregateOtherTrackedEntity[P]>
}




export type OtherTrackedEntityGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.OtherTrackedEntityWhereInput
  orderBy?: Prisma.OtherTrackedEntityOrderByWithAggregationInput | Prisma.OtherTrackedEntityOrderByWithAggregationInput[]
  by: Prisma.OtherTrackedEntityScalarFieldEnum[] | Prisma.OtherTrackedEntityScalarFieldEnum
  having?: Prisma.OtherTrackedEntityScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: OtherTrackedEntityCountAggregateInputType | true
  _min?: OtherTrackedEntityMinAggregateInputType
  _max?: OtherTrackedEntityMaxAggregateInputType
}

export type OtherTrackedEntityGroupByOutputType = {
  id: string
  facebookPageUrl: string
  createdAt: Date
  updatedAt: Date
  _count: OtherTrackedEntityCountAggregateOutputType | null
  _min: OtherTrackedEntityMinAggregateOutputType | null
  _max: OtherTrackedEntityMaxAggregateOutputType | null
}

type GetOtherTrackedEntityGroupByPayload<T extends OtherTrackedEntityGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<OtherTrackedEntityGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof OtherTrackedEntityGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], OtherTrackedEntityGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], OtherTrackedEntityGroupByOutputType[P]>
      }
    >
  >



export type OtherTrackedEntityWhereInput = {
  AND?: Prisma.OtherTrackedEntityWhereInput | Prisma.OtherTrackedEntityWhereInput[]
  OR?: Prisma.OtherTrackedEntityWhereInput[]
  NOT?: Prisma.OtherTrackedEntityWhereInput | Prisma.OtherTrackedEntityWhereInput[]
  id?: Prisma.StringFilter<"OtherTrackedEntity"> | string
  facebookPageUrl?: Prisma.StringFilter<"OtherTrackedEntity"> | string
  createdAt?: Prisma.DateTimeFilter<"OtherTrackedEntity"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"OtherTrackedEntity"> | Date | string
  trackedEntityOtherTrackedEntity?: Prisma.XOR<Prisma.TrackedEntityOtherTrackedEntityNullableScalarRelationFilter, Prisma.TrackedEntityOtherTrackedEntityWhereInput> | null
}

export type OtherTrackedEntityOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  facebookPageUrl?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  trackedEntityOtherTrackedEntity?: Prisma.TrackedEntityOtherTrackedEntityOrderByWithRelationInput
}

export type OtherTrackedEntityWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  facebookPageUrl?: string
  AND?: Prisma.OtherTrackedEntityWhereInput | Prisma.OtherTrackedEntityWhereInput[]
  OR?: Prisma.OtherTrackedEntityWhereInput[]
  NOT?: Prisma.OtherTrackedEntityWhereInput | Prisma.OtherTrackedEntityWhereInput[]
  createdAt?: Prisma.DateTimeFilter<"OtherTrackedEntity"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"OtherTrackedEntity"> | Date | string
  trackedEntityOtherTrackedEntity?: Prisma.XOR<Prisma.TrackedEntityOtherTrackedEntityNullableScalarRelationFilter, Prisma.TrackedEntityOtherTrackedEntityWhereInput> | null
}, "id" | "facebookPageUrl">

export type OtherTrackedEntityOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  facebookPageUrl?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.OtherTrackedEntityCountOrderByAggregateInput
  _max?: Prisma.OtherTrackedEntityMaxOrderByAggregateInput
  _min?: Prisma.OtherTrackedEntityMinOrderByAggregateInput
}

export type OtherTrackedEntityScalarWhereWithAggregatesInput = {
  AND?: Prisma.OtherTrackedEntityScalarWhereWithAggregatesInput | Prisma.OtherTrackedEntityScalarWhereWithAggregatesInput[]
  OR?: Prisma.OtherTrackedEntityScalarWhereWithAggregatesInput[]
  NOT?: Prisma.OtherTrackedEntityScalarWhereWithAggregatesInput | Prisma.OtherTrackedEntityScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"OtherTrackedEntity"> | string
  facebookPageUrl?: Prisma.StringWithAggregatesFilter<"OtherTrackedEntity"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"OtherTrackedEntity"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"OtherTrackedEntity"> | Date | string
}

export type OtherTrackedEntityCreateInput = {
  id?: string
  facebookPageUrl: string
  createdAt?: Date | string
  updatedAt?: Date | string
  trackedEntityOtherTrackedEntity?: Prisma.TrackedEntityOtherTrackedEntityCreateNestedOneWithoutOtherTrackedEntityInput
}

export type OtherTrackedEntityUncheckedCreateInput = {
  id?: string
  facebookPageUrl: string
  createdAt?: Date | string
  updatedAt?: Date | string
  trackedEntityOtherTrackedEntity?: Prisma.TrackedEntityOtherTrackedEntityUncheckedCreateNestedOneWithoutOtherTrackedEntityInput
}

export type OtherTrackedEntityUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  facebookPageUrl?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  trackedEntityOtherTrackedEntity?: Prisma.TrackedEntityOtherTrackedEntityUpdateOneWithoutOtherTrackedEntityNestedInput
}

export type OtherTrackedEntityUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  facebookPageUrl?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  trackedEntityOtherTrackedEntity?: Prisma.TrackedEntityOtherTrackedEntityUncheckedUpdateOneWithoutOtherTrackedEntityNestedInput
}

export type OtherTrackedEntityCreateManyInput = {
  id?: string
  facebookPageUrl: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type OtherTrackedEntityUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  facebookPageUrl?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type OtherTrackedEntityUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  facebookPageUrl?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type OtherTrackedEntityScalarRelationFilter = {
  is?: Prisma.OtherTrackedEntityWhereInput
  isNot?: Prisma.OtherTrackedEntityWhereInput
}

export type OtherTrackedEntityCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  facebookPageUrl?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type OtherTrackedEntityMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  facebookPageUrl?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type OtherTrackedEntityMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  facebookPageUrl?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type OtherTrackedEntityCreateNestedOneWithoutTrackedEntityOtherTrackedEntityInput = {
  create?: Prisma.XOR<Prisma.OtherTrackedEntityCreateWithoutTrackedEntityOtherTrackedEntityInput, Prisma.OtherTrackedEntityUncheckedCreateWithoutTrackedEntityOtherTrackedEntityInput>
  connectOrCreate?: Prisma.OtherTrackedEntityCreateOrConnectWithoutTrackedEntityOtherTrackedEntityInput
  connect?: Prisma.OtherTrackedEntityWhereUniqueInput
}

export type OtherTrackedEntityUpdateOneRequiredWithoutTrackedEntityOtherTrackedEntityNestedInput = {
  create?: Prisma.XOR<Prisma.OtherTrackedEntityCreateWithoutTrackedEntityOtherTrackedEntityInput, Prisma.OtherTrackedEntityUncheckedCreateWithoutTrackedEntityOtherTrackedEntityInput>
  connectOrCreate?: Prisma.OtherTrackedEntityCreateOrConnectWithoutTrackedEntityOtherTrackedEntityInput
  upsert?: Prisma.OtherTrackedEntityUpsertWithoutTrackedEntityOtherTrackedEntityInput
  connect?: Prisma.OtherTrackedEntityWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.OtherTrackedEntityUpdateToOneWithWhereWithoutTrackedEntityOtherTrackedEntityInput, Prisma.OtherTrackedEntityUpdateWithoutTrackedEntityOtherTrackedEntityInput>, Prisma.OtherTrackedEntityUncheckedUpdateWithoutTrackedEntityOtherTrackedEntityInput>
}

export type OtherTrackedEntityCreateWithoutTrackedEntityOtherTrackedEntityInput = {
  id?: string
  facebookPageUrl: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type OtherTrackedEntityUncheckedCreateWithoutTrackedEntityOtherTrackedEntityInput = {
  id?: string
  facebookPageUrl: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type OtherTrackedEntityCreateOrConnectWithoutTrackedEntityOtherTrackedEntityInput = {
  where: Prisma.OtherTrackedEntityWhereUniqueInput
  create: Prisma.XOR<Prisma.OtherTrackedEntityCreateWithoutTrackedEntityOtherTrackedEntityInput, Prisma.OtherTrackedEntityUncheckedCreateWithoutTrackedEntityOtherTrackedEntityInput>
}

export type OtherTrackedEntityUpsertWithoutTrackedEntityOtherTrackedEntityInput = {
  update: Prisma.XOR<Prisma.OtherTrackedEntityUpdateWithoutTrackedEntityOtherTrackedEntityInput, Prisma.OtherTrackedEntityUncheckedUpdateWithoutTrackedEntityOtherTrackedEntityInput>
  create: Prisma.XOR<Prisma.OtherTrackedEntityCreateWithoutTrackedEntityOtherTrackedEntityInput, Prisma.OtherTrackedEntityUncheckedCreateWithoutTrackedEntityOtherTrackedEntityInput>
  where?: Prisma.OtherTrackedEntityWhereInput
}

export type OtherTrackedEntityUpdateToOneWithWhereWithoutTrackedEntityOtherTrackedEntityInput = {
  where?: Prisma.OtherTrackedEntityWhereInput
  data: Prisma.XOR<Prisma.OtherTrackedEntityUpdateWithoutTrackedEntityOtherTrackedEntityInput, Prisma.OtherTrackedEntityUncheckedUpdateWithoutTrackedEntityOtherTrackedEntityInput>
}

export type OtherTrackedEntityUpdateWithoutTrackedEntityOtherTrackedEntityInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  facebookPageUrl?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type OtherTrackedEntityUncheckedUpdateWithoutTrackedEntityOtherTrackedEntityInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  facebookPageUrl?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type OtherTrackedEntitySelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  facebookPageUrl?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  trackedEntityOtherTrackedEntity?: boolean | Prisma.OtherTrackedEntity$trackedEntityOtherTrackedEntityArgs<ExtArgs>
}, ExtArgs["result"]["otherTrackedEntity"]>

export type OtherTrackedEntitySelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  facebookPageUrl?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}, ExtArgs["result"]["otherTrackedEntity"]>

export type OtherTrackedEntitySelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  facebookPageUrl?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}, ExtArgs["result"]["otherTrackedEntity"]>

export type OtherTrackedEntitySelectScalar = {
  id?: boolean
  facebookPageUrl?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type OtherTrackedEntityOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "facebookPageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["otherTrackedEntity"]>
export type OtherTrackedEntityInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  trackedEntityOtherTrackedEntity?: boolean | Prisma.OtherTrackedEntity$trackedEntityOtherTrackedEntityArgs<ExtArgs>
}
export type OtherTrackedEntityIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}
export type OtherTrackedEntityIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}

export type $OtherTrackedEntityPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "OtherTrackedEntity"
  objects: {
    trackedEntityOtherTrackedEntity: Prisma.$TrackedEntityOtherTrackedEntityPayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    facebookPageUrl: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["otherTrackedEntity"]>
  composites: {}
}

export type OtherTrackedEntityGetPayload<S extends boolean | null | undefined | OtherTrackedEntityDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$OtherTrackedEntityPayload, S>

export type OtherTrackedEntityCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<OtherTrackedEntityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: OtherTrackedEntityCountAggregateInputType | true
  }

export interface OtherTrackedEntityDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OtherTrackedEntity'], meta: { name: 'OtherTrackedEntity' } }
  /**
   * Find zero or one OtherTrackedEntity that matches the filter.
   * @param {OtherTrackedEntityFindUniqueArgs} args - Arguments to find a OtherTrackedEntity
   * @example
   * // Get one OtherTrackedEntity
   * const otherTrackedEntity = await prisma.otherTrackedEntity.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends OtherTrackedEntityFindUniqueArgs>(args: Prisma.SelectSubset<T, OtherTrackedEntityFindUniqueArgs<ExtArgs>>): Prisma.Prisma__OtherTrackedEntityClient<runtime.Types.Result.GetResult<Prisma.$OtherTrackedEntityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one OtherTrackedEntity that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {OtherTrackedEntityFindUniqueOrThrowArgs} args - Arguments to find a OtherTrackedEntity
   * @example
   * // Get one OtherTrackedEntity
   * const otherTrackedEntity = await prisma.otherTrackedEntity.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends OtherTrackedEntityFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, OtherTrackedEntityFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__OtherTrackedEntityClient<runtime.Types.Result.GetResult<Prisma.$OtherTrackedEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first OtherTrackedEntity that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OtherTrackedEntityFindFirstArgs} args - Arguments to find a OtherTrackedEntity
   * @example
   * // Get one OtherTrackedEntity
   * const otherTrackedEntity = await prisma.otherTrackedEntity.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends OtherTrackedEntityFindFirstArgs>(args?: Prisma.SelectSubset<T, OtherTrackedEntityFindFirstArgs<ExtArgs>>): Prisma.Prisma__OtherTrackedEntityClient<runtime.Types.Result.GetResult<Prisma.$OtherTrackedEntityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first OtherTrackedEntity that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OtherTrackedEntityFindFirstOrThrowArgs} args - Arguments to find a OtherTrackedEntity
   * @example
   * // Get one OtherTrackedEntity
   * const otherTrackedEntity = await prisma.otherTrackedEntity.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends OtherTrackedEntityFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, OtherTrackedEntityFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__OtherTrackedEntityClient<runtime.Types.Result.GetResult<Prisma.$OtherTrackedEntityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more OtherTrackedEntities that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OtherTrackedEntityFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all OtherTrackedEntities
   * const otherTrackedEntities = await prisma.otherTrackedEntity.findMany()
   * 
   * // Get first 10 OtherTrackedEntities
   * const otherTrackedEntities = await prisma.otherTrackedEntity.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const otherTrackedEntityWithIdOnly = await prisma.otherTrackedEntity.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends OtherTrackedEntityFindManyArgs>(args?: Prisma.SelectSubset<T, OtherTrackedEntityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$OtherTrackedEntityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a OtherTrackedEntity.
   * @param {OtherTrackedEntityCreateArgs} args - Arguments to create a OtherTrackedEntity.
   * @example
   * // Create one OtherTrackedEntity
   * const OtherTrackedEntity = await prisma.otherTrackedEntity.create({
   *   data: {
   *     // ... data to create a OtherTrackedEntity
   *   }
   * })
   * 
   */
  create<T extends OtherTrackedEntityCreateArgs>(args: Prisma.SelectSubset<T, OtherTrackedEntityCreateArgs<ExtArgs>>): Prisma.Prisma__OtherTrackedEntityClient<runtime.Types.Result.GetResult<Prisma.$OtherTrackedEntityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many OtherTrackedEntities.
   * @param {OtherTrackedEntityCreateManyArgs} args - Arguments to create many OtherTrackedEntities.
   * @example
   * // Create many OtherTrackedEntities
   * const otherTrackedEntity = await prisma.otherTrackedEntity.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends OtherTrackedEntityCreateManyArgs>(args?: Prisma.SelectSubset<T, OtherTrackedEntityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many OtherTrackedEntities and returns the data saved in the database.
   * @param {OtherTrackedEntityCreateManyAndReturnArgs} args - Arguments to create many OtherTrackedEntities.
   * @example
   * // Create many OtherTrackedEntities
   * const otherTrackedEntity = await prisma.otherTrackedEntity.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many OtherTrackedEntities and only return the `id`
   * const otherTrackedEntityWithIdOnly = await prisma.otherTrackedEntity.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends OtherTrackedEntityCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, OtherTrackedEntityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$OtherTrackedEntityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a OtherTrackedEntity.
   * @param {OtherTrackedEntityDeleteArgs} args - Arguments to delete one OtherTrackedEntity.
   * @example
   * // Delete one OtherTrackedEntity
   * const OtherTrackedEntity = await prisma.otherTrackedEntity.delete({
   *   where: {
   *     // ... filter to delete one OtherTrackedEntity
   *   }
   * })
   * 
   */
  delete<T extends OtherTrackedEntityDeleteArgs>(args: Prisma.SelectSubset<T, OtherTrackedEntityDeleteArgs<ExtArgs>>): Prisma.Prisma__OtherTrackedEntityClient<runtime.Types.Result.GetResult<Prisma.$OtherTrackedEntityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one OtherTrackedEntity.
   * @param {OtherTrackedEntityUpdateArgs} args - Arguments to update one OtherTrackedEntity.
   * @example
   * // Update one OtherTrackedEntity
   * const otherTrackedEntity = await prisma.otherTrackedEntity.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends OtherTrackedEntityUpdateArgs>(args: Prisma.SelectSubset<T, OtherTrackedEntityUpdateArgs<ExtArgs>>): Prisma.Prisma__OtherTrackedEntityClient<runtime.Types.Result.GetResult<Prisma.$OtherTrackedEntityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more OtherTrackedEntities.
   * @param {OtherTrackedEntityDeleteManyArgs} args - Arguments to filter OtherTrackedEntities to delete.
   * @example
   * // Delete a few OtherTrackedEntities
   * const { count } = await prisma.otherTrackedEntity.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends OtherTrackedEntityDeleteManyArgs>(args?: Prisma.SelectSubset<T, OtherTrackedEntityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more OtherTrackedEntities.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OtherTrackedEntityUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many OtherTrackedEntities
   * const otherTrackedEntity = await prisma.otherTrackedEntity.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends OtherTrackedEntityUpdateManyArgs>(args: Prisma.SelectSubset<T, OtherTrackedEntityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more OtherTrackedEntities and returns the data updated in the database.
   * @param {OtherTrackedEntityUpdateManyAndReturnArgs} args - Arguments to update many OtherTrackedEntities.
   * @example
   * // Update many OtherTrackedEntities
   * const otherTrackedEntity = await prisma.otherTrackedEntity.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more OtherTrackedEntities and only return the `id`
   * const otherTrackedEntityWithIdOnly = await prisma.otherTrackedEntity.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends OtherTrackedEntityUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, OtherTrackedEntityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$OtherTrackedEntityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one OtherTrackedEntity.
   * @param {OtherTrackedEntityUpsertArgs} args - Arguments to update or create a OtherTrackedEntity.
   * @example
   * // Update or create a OtherTrackedEntity
   * const otherTrackedEntity = await prisma.otherTrackedEntity.upsert({
   *   create: {
   *     // ... data to create a OtherTrackedEntity
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the OtherTrackedEntity we want to update
   *   }
   * })
   */
  upsert<T extends OtherTrackedEntityUpsertArgs>(args: Prisma.SelectSubset<T, OtherTrackedEntityUpsertArgs<ExtArgs>>): Prisma.Prisma__OtherTrackedEntityClient<runtime.Types.Result.GetResult<Prisma.$OtherTrackedEntityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of OtherTrackedEntities.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OtherTrackedEntityCountArgs} args - Arguments to filter OtherTrackedEntities to count.
   * @example
   * // Count the number of OtherTrackedEntities
   * const count = await prisma.otherTrackedEntity.count({
   *   where: {
   *     // ... the filter for the OtherTrackedEntities we want to count
   *   }
   * })
  **/
  count<T extends OtherTrackedEntityCountArgs>(
    args?: Prisma.Subset<T, OtherTrackedEntityCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], OtherTrackedEntityCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a OtherTrackedEntity.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OtherTrackedEntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends OtherTrackedEntityAggregateArgs>(args: Prisma.Subset<T, OtherTrackedEntityAggregateArgs>): Prisma.PrismaPromise<GetOtherTrackedEntityAggregateType<T>>

  /**
   * Group by OtherTrackedEntity.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OtherTrackedEntityGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends OtherTrackedEntityGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: OtherTrackedEntityGroupByArgs['orderBy'] }
      : { orderBy?: OtherTrackedEntityGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, OtherTrackedEntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtherTrackedEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the OtherTrackedEntity model
 */
readonly fields: OtherTrackedEntityFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for OtherTrackedEntity.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__OtherTrackedEntityClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  trackedEntityOtherTrackedEntity<T extends Prisma.OtherTrackedEntity$trackedEntityOtherTrackedEntityArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.OtherTrackedEntity$trackedEntityOtherTrackedEntityArgs<ExtArgs>>): Prisma.Prisma__TrackedEntityOtherTrackedEntityClient<runtime.Types.Result.GetResult<Prisma.$TrackedEntityOtherTrackedEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the OtherTrackedEntity model
 */
export interface OtherTrackedEntityFieldRefs {
  readonly id: Prisma.FieldRef<"OtherTrackedEntity", 'String'>
  readonly facebookPageUrl: Prisma.FieldRef<"OtherTrackedEntity", 'String'>
  readonly createdAt: Prisma.FieldRef<"OtherTrackedEntity", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"OtherTrackedEntity", 'DateTime'>
}
    

// Custom InputTypes
/**
 * OtherTrackedEntity findUnique
 */
export type OtherTrackedEntityFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the OtherTrackedEntity
   */
  select?: Prisma.OtherTrackedEntitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the OtherTrackedEntity
   */
  omit?: Prisma.OtherTrackedEntityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OtherTrackedEntityInclude<ExtArgs> | null
  /**
   * Filter, which OtherTrackedEntity to fetch.
   */
  where: Prisma.OtherTrackedEntityWhereUniqueInput
}

/**
 * OtherTrackedEntity findUniqueOrThrow
 */
export type OtherTrackedEntityFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the OtherTrackedEntity
   */
  select?: Prisma.OtherTrackedEntitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the OtherTrackedEntity
   */
  omit?: Prisma.OtherTrackedEntityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OtherTrackedEntityInclude<ExtArgs> | null
  /**
   * Filter, which OtherTrackedEntity to fetch.
   */
  where: Prisma.OtherTrackedEntityWhereUniqueInput
}

/**
 * OtherTrackedEntity findFirst
 */
export type OtherTrackedEntityFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the OtherTrackedEntity
   */
  select?: Prisma.OtherTrackedEntitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the OtherTrackedEntity
   */
  omit?: Prisma.OtherTrackedEntityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OtherTrackedEntityInclude<ExtArgs> | null
  /**
   * Filter, which OtherTrackedEntity to fetch.
   */
  where?: Prisma.OtherTrackedEntityWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of OtherTrackedEntities to fetch.
   */
  orderBy?: Prisma.OtherTrackedEntityOrderByWithRelationInput | Prisma.OtherTrackedEntityOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for OtherTrackedEntities.
   */
  cursor?: Prisma.OtherTrackedEntityWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` OtherTrackedEntities from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` OtherTrackedEntities.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of OtherTrackedEntities.
   */
  distinct?: Prisma.OtherTrackedEntityScalarFieldEnum | Prisma.OtherTrackedEntityScalarFieldEnum[]
}

/**
 * OtherTrackedEntity findFirstOrThrow
 */
export type OtherTrackedEntityFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the OtherTrackedEntity
   */
  select?: Prisma.OtherTrackedEntitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the OtherTrackedEntity
   */
  omit?: Prisma.OtherTrackedEntityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OtherTrackedEntityInclude<ExtArgs> | null
  /**
   * Filter, which OtherTrackedEntity to fetch.
   */
  where?: Prisma.OtherTrackedEntityWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of OtherTrackedEntities to fetch.
   */
  orderBy?: Prisma.OtherTrackedEntityOrderByWithRelationInput | Prisma.OtherTrackedEntityOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for OtherTrackedEntities.
   */
  cursor?: Prisma.OtherTrackedEntityWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` OtherTrackedEntities from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` OtherTrackedEntities.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of OtherTrackedEntities.
   */
  distinct?: Prisma.OtherTrackedEntityScalarFieldEnum | Prisma.OtherTrackedEntityScalarFieldEnum[]
}

/**
 * OtherTrackedEntity findMany
 */
export type OtherTrackedEntityFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the OtherTrackedEntity
   */
  select?: Prisma.OtherTrackedEntitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the OtherTrackedEntity
   */
  omit?: Prisma.OtherTrackedEntityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OtherTrackedEntityInclude<ExtArgs> | null
  /**
   * Filter, which OtherTrackedEntities to fetch.
   */
  where?: Prisma.OtherTrackedEntityWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of OtherTrackedEntities to fetch.
   */
  orderBy?: Prisma.OtherTrackedEntityOrderByWithRelationInput | Prisma.OtherTrackedEntityOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing OtherTrackedEntities.
   */
  cursor?: Prisma.OtherTrackedEntityWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` OtherTrackedEntities from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` OtherTrackedEntities.
   */
  skip?: number
  distinct?: Prisma.OtherTrackedEntityScalarFieldEnum | Prisma.OtherTrackedEntityScalarFieldEnum[]
}

/**
 * OtherTrackedEntity create
 */
export type OtherTrackedEntityCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the OtherTrackedEntity
   */
  select?: Prisma.OtherTrackedEntitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the OtherTrackedEntity
   */
  omit?: Prisma.OtherTrackedEntityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OtherTrackedEntityInclude<ExtArgs> | null
  /**
   * The data needed to create a OtherTrackedEntity.
   */
  data: Prisma.XOR<Prisma.OtherTrackedEntityCreateInput, Prisma.OtherTrackedEntityUncheckedCreateInput>
}

/**
 * OtherTrackedEntity createMany
 */
export type OtherTrackedEntityCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many OtherTrackedEntities.
   */
  data: Prisma.OtherTrackedEntityCreateManyInput | Prisma.OtherTrackedEntityCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * OtherTrackedEntity createManyAndReturn
 */
export type OtherTrackedEntityCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the OtherTrackedEntity
   */
  select?: Prisma.OtherTrackedEntitySelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the OtherTrackedEntity
   */
  omit?: Prisma.OtherTrackedEntityOmit<ExtArgs> | null
  /**
   * The data used to create many OtherTrackedEntities.
   */
  data: Prisma.OtherTrackedEntityCreateManyInput | Prisma.OtherTrackedEntityCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * OtherTrackedEntity update
 */
export type OtherTrackedEntityUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the OtherTrackedEntity
   */
  select?: Prisma.OtherTrackedEntitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the OtherTrackedEntity
   */
  omit?: Prisma.OtherTrackedEntityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OtherTrackedEntityInclude<ExtArgs> | null
  /**
   * The data needed to update a OtherTrackedEntity.
   */
  data: Prisma.XOR<Prisma.OtherTrackedEntityUpdateInput, Prisma.OtherTrackedEntityUncheckedUpdateInput>
  /**
   * Choose, which OtherTrackedEntity to update.
   */
  where: Prisma.OtherTrackedEntityWhereUniqueInput
}

/**
 * OtherTrackedEntity updateMany
 */
export type OtherTrackedEntityUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update OtherTrackedEntities.
   */
  data: Prisma.XOR<Prisma.OtherTrackedEntityUpdateManyMutationInput, Prisma.OtherTrackedEntityUncheckedUpdateManyInput>
  /**
   * Filter which OtherTrackedEntities to update
   */
  where?: Prisma.OtherTrackedEntityWhereInput
  /**
   * Limit how many OtherTrackedEntities to update.
   */
  limit?: number
}

/**
 * OtherTrackedEntity updateManyAndReturn
 */
export type OtherTrackedEntityUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the OtherTrackedEntity
   */
  select?: Prisma.OtherTrackedEntitySelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the OtherTrackedEntity
   */
  omit?: Prisma.OtherTrackedEntityOmit<ExtArgs> | null
  /**
   * The data used to update OtherTrackedEntities.
   */
  data: Prisma.XOR<Prisma.OtherTrackedEntityUpdateManyMutationInput, Prisma.OtherTrackedEntityUncheckedUpdateManyInput>
  /**
   * Filter which OtherTrackedEntities to update
   */
  where?: Prisma.OtherTrackedEntityWhereInput
  /**
   * Limit how many OtherTrackedEntities to update.
   */
  limit?: number
}

/**
 * OtherTrackedEntity upsert
 */
export type OtherTrackedEntityUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the OtherTrackedEntity
   */
  select?: Prisma.OtherTrackedEntitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the OtherTrackedEntity
   */
  omit?: Prisma.OtherTrackedEntityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OtherTrackedEntityInclude<ExtArgs> | null
  /**
   * The filter to search for the OtherTrackedEntity to update in case it exists.
   */
  where: Prisma.OtherTrackedEntityWhereUniqueInput
  /**
   * In case the OtherTrackedEntity found by the `where` argument doesn't exist, create a new OtherTrackedEntity with this data.
   */
  create: Prisma.XOR<Prisma.OtherTrackedEntityCreateInput, Prisma.OtherTrackedEntityUncheckedCreateInput>
  /**
   * In case the OtherTrackedEntity was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.OtherTrackedEntityUpdateInput, Prisma.OtherTrackedEntityUncheckedUpdateInput>
}

/**
 * OtherTrackedEntity delete
 */
export type OtherTrackedEntityDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the OtherTrackedEntity
   */
  select?: Prisma.OtherTrackedEntitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the OtherTrackedEntity
   */
  omit?: Prisma.OtherTrackedEntityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OtherTrackedEntityInclude<ExtArgs> | null
  /**
   * Filter which OtherTrackedEntity to delete.
   */
  where: Prisma.OtherTrackedEntityWhereUniqueInput
}

/**
 * OtherTrackedEntity deleteMany
 */
export type OtherTrackedEntityDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which OtherTrackedEntities to delete
   */
  where?: Prisma.OtherTrackedEntityWhereInput
  /**
   * Limit how many OtherTrackedEntities to delete.
   */
  limit?: number
}

/**
 * OtherTrackedEntity.trackedEntityOtherTrackedEntity
 */
export type OtherTrackedEntity$trackedEntityOtherTrackedEntityArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the TrackedEntityOtherTrackedEntity
   */
  select?: Prisma.TrackedEntityOtherTrackedEntitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the TrackedEntityOtherTrackedEntity
   */
  omit?: Prisma.TrackedEntityOtherTrackedEntityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TrackedEntityOtherTrackedEntityInclude<ExtArgs> | null
  where?: Prisma.TrackedEntityOtherTrackedEntityWhereInput
}

/**
 * OtherTrackedEntity without action
 */
export type OtherTrackedEntityDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the OtherTrackedEntity
   */
  select?: Prisma.OtherTrackedEntitySelect<ExtArgs> | null
  /**
   * Omit specific fields from the OtherTrackedEntity
   */
  omit?: Prisma.OtherTrackedEntityOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OtherTrackedEntityInclude<ExtArgs> | null
}
